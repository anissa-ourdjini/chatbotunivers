<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Explorateur 3D - Univers</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
        }
        #canvas {
            display: block;
            width: 100%;
            height: 100vh;
        }
        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            max-width: 300px;
            font-size: 13px;
            z-index: 10;
        }
        .controls h3 {
            margin-bottom: 15px;
            color: #00d4ff;
        }
        .control-item {
            margin: 10px 0;
            padding: 8px;
            background: rgba(0, 212, 255, 0.1);
            border-radius: 5px;
            border-left: 3px solid #00d4ff;
        }
        .control-item strong {
            color: #00d4ff;
        }
        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }
        button {
            padding: 10px 15px;
            background: #00d4ff;
            color: #000;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            font-size: 12px;
            transition: all 0.3s;
        }
        button:hover {
            background: #00a8cc;
            transform: scale(1.05);
        }
        .info-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            max-width: 350px;
            font-size: 13px;
            z-index: 10;
        }
        .info-panel h4 {
            color: #00d4ff;
            margin-bottom: 10px;
        }
        .info-item {
            margin: 8px 0;
            padding: 5px;
            border-bottom: 1px solid rgba(0, 212, 255, 0.3);
        }
        .back-button {
            position: absolute;
            bottom: 20px;
            left: 20px;
            padding: 12px 25px;
            background: #ff6b6b;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            z-index: 10;
        }
        .back-button:hover {
            background: #ff5252;
            transform: scale(1.05);
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div class="controls">
        <h3>üöÄ CONTR√îLES</h3>
        <div class="control-item">
            <strong>Souris:</strong> Rotation
        </div>
        <div class="control-item">
            <strong>Scroll:</strong> Zoom
        </div>
        <div class="control-item">
            <strong>Clic:</strong> S√©lectionner
        </div>
        <div class="button-group">
            <button onclick="goToSun()">‚òÄÔ∏è Soleil</button>
            <button onclick="goToEarth()">üåç Terre</button>
            <button onclick="goToMars()">üî¥ Mars</button>
            <button onclick="resetView()">‚Ü∫ R√©initialiser</button>
        </div>
        <div class="button-group">
            <button onclick="toggleOrbit()">‚óâ Orbites</button>
            <button onclick="toggleLabels()">üî§ Noms</button>
        </div>
    </div>

    <div class="info-panel">
        <h4>‚ÑπÔ∏è INFORMATIONS</h4>
        <div class="info-item">
            <strong>Objet:</strong> <span id="selectedObject">Aucun</span>
        </div>
        <div class="info-item">
            <strong>Distance:</strong> <span id="distance">--</span> UA
        </div>
        <div class="info-item">
            <strong>Taille:</strong> <span id="size">--</span> km
        </div>
        <div class="info-item">
            <strong>Temp√©rature:</strong> <span id="temperature">--</span> K
        </div>
        <div class="info-item">
            <strong>Type:</strong> <span id="type">--</span>
        </div>
    </div>

    <button class="back-button" onclick="goBack()">‚Üê Retour au Chat</button>

    <script>
        // Configuration WebGL
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl2');
        
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        if (!gl) {
            alert('WebGL2 n\'est pas support√©');
            document.body.innerHTML = '<h1>WebGL2 requis</h1>';
        }

        // Variables de cam√©ra
        let camera = {
            x: 0,
            y: 15,
            z: 50,
            rotX: 0,
            rotY: 0
        };

        // √âtat
        let showOrbits = true;
        let showLabels = true;
        let selectedObject = null;

        // Donn√©es des plan√®tes
        const celestialBodies = [
            { name: 'Soleil', x: 0, y: 0, z: 0, size: 2, color: [1, 0.8, 0], distance: 0, temp: 5778, type: '√âtoile' },
            { name: 'Mercure', x: 5, y: 0, z: 0, size: 0.38, color: [0.7, 0.7, 0.7], distance: 0.39, temp: 430, type: 'Plan√®te rocheuse', orbitRadius: 5 },
            { name: 'V√©nus', x: 8, y: 0, z: 0, size: 0.95, color: [1, 0.9, 0.3], distance: 0.72, temp: 735, type: 'Plan√®te rocheuse', orbitRadius: 8 },
            { name: 'Terre', x: 12, y: 0, z: 0, size: 1, color: [0.2, 0.6, 1], distance: 1, temp: 288, type: 'Plan√®te rocheuse', orbitRadius: 12 },
            { name: 'Mars', x: 16, y: 0, z: 0, size: 0.53, color: [1, 0.4, 0], distance: 1.52, temp: 210, type: 'Plan√®te rocheuse', orbitRadius: 16 },
            { name: 'Jupiter', x: 30, y: 0, z: 0, size: 11.2, color: [1, 0.85, 0.5], distance: 5.2, temp: 165, type: 'G√©ante gazeuse', orbitRadius: 30 },
            { name: 'Saturne', x: 45, y: 0, z: 0, size: 9.4, color: [1, 0.95, 0.7], distance: 9.5, temp: 135, type: 'G√©ante gazeuse', orbitRadius: 45 },
            { name: 'Uranus', x: 60, y: 0, z: 0, size: 4, color: [0.5, 0.8, 1], distance: 19.2, temp: 76, type: 'G√©ante de glace', orbitRadius: 60 },
            { name: 'Neptune', x: 75, y: 0, z: 0, size: 3.9, color: [0.2, 0.4, 1], distance: 30.1, temp: 72, type: 'G√©ante de glace', orbitRadius: 75 }
        ];

        // Shaders
        const vertexShaderSource = `#version 300 es
            in vec3 position;
            uniform mat4 projMatrix;
            uniform mat4 viewMatrix;
            uniform mat4 modelMatrix;
            
            void main() {
                gl_Position = projMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);
            }
        `;

        const fragmentShaderSource = `#version 300 es
            precision highp float;
            uniform vec3 color;
            
            void main() {
                gl_FragColor = vec4(color, 1.0);
            }
        `;

        // Compilation des shaders
        function compileShader(source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
                return null;
            }
            return shader;
        }

        // Programme shader
        const vertexShader = compileShader(vertexShaderSource, gl.VERTEX_SHADER);
        const fragmentShader = compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error(gl.getProgramInfoLog(program));
        }

        gl.useProgram(program);

        // Cr√©er une sph√®re
        function createSphere(radius, segments = 32) {
            const positions = [];
            const indices = [];

            for (let i = 0; i <= segments; i++) {
                const theta = (i / segments) * Math.PI;
                for (let j = 0; j <= segments; j++) {
                    const phi = (j / segments) * 2 * Math.PI;
                    
                    const x = radius * Math.sin(theta) * Math.cos(phi);
                    const y = radius * Math.cos(theta);
                    const z = radius * Math.sin(theta) * Math.sin(phi);
                    
                    positions.push(x, y, z);
                }
            }

            for (let i = 0; i < segments; i++) {
                for (let j = 0; j < segments; j++) {
                    const a = i * (segments + 1) + j;
                    const b = a + segments + 1;
                    
                    indices.push(a, b, a + 1);
                    indices.push(b, b + 1, a + 1);
                }
            }

            return { positions, indices };
        }

        // Cr√©er les VBO
        const sphere = createSphere(1, 16);
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(sphere.positions), gl.STATIC_DRAW);

        const indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(sphere.indices), gl.STATIC_DRAW);

        const positionLocation = gl.getAttribLocation(program, 'position');
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 0, 0);

        // Matrices
        function multiplyMatrices(a, b) {
            const result = new Array(16);
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    result[i * 4 + j] = 0;
                    for (let k = 0; k < 4; k++) {
                        result[i * 4 + j] += a[i * 4 + k] * b[k * 4 + j];
                    }
                }
            }
            return result;
        }

        function perspectiveMatrix(fov, aspect, near, far) {
            const f = 1 / Math.tan(fov / 2);
            const nf = 1 / (near - far);
            return [
                f / aspect, 0, 0, 0,
                0, f, 0, 0,
                0, 0, (far + near) * nf, -1,
                0, 0, 2 * far * near * nf, 0
            ];
        }

        function translateMatrix(x, y, z) {
            return [
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                x, y, z, 1
            ];
        }

        function scaleMatrix(x, y, z) {
            return [
                x, 0, 0, 0,
                0, y, 0, 0,
                0, 0, z, 0,
                0, 0, 0, 1
            ];
        }

        function rotateYMatrix(angle) {
            const c = Math.cos(angle);
            const s = Math.sin(angle);
            return [
                c, 0, s, 0,
                0, 1, 0, 0,
                -s, 0, c, 0,
                0, 0, 0, 1
            ];
        }

        // Boucle d'animation
        let time = 0;
        let angle = 0;

        function animate() {
            time++;
            angle += 0.01;

            gl.clearColor(0, 0, 0, 1);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.enable(gl.DEPTH_TEST);

            const projMatrix = perspectiveMatrix(Math.PI / 4, canvas.width / canvas.height, 0.1, 1000);
            const viewMatrix = [
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                -camera.x, -camera.y, -camera.z, 1
            ];

            const projLoc = gl.getUniformLocation(program, 'projMatrix');
            const viewLoc = gl.getUniformLocation(program, 'viewMatrix');
            const modelLoc = gl.getUniformLocation(program, 'modelMatrix');
            const colorLoc = gl.getUniformLocation(program, 'color');

            gl.uniformMatrix4fv(projLoc, false, projMatrix);
            gl.uniformMatrix4fv(viewLoc, false, viewMatrix);

            // Dessiner les plan√®tes
            celestialBodies.forEach((body, index) => {
                let x = body.x;
                let y = body.y;
                let z = body.z;

                if (body.orbitRadius) {
                    x = body.orbitRadius * Math.cos(angle);
                    z = body.orbitRadius * Math.sin(angle);
                }

                const modelMatrix = multiplyMatrices(
                    translateMatrix(x, y, z),
                    scaleMatrix(body.size, body.size, body.size)
                );

                gl.uniformMatrix4fv(modelLoc, false, modelMatrix);
                gl.uniform3f(colorLoc, body.color[0], body.color[1], body.color[2]);
                gl.drawElements(gl.TRIANGLES, sphere.indices.length, gl.UNSIGNED_SHORT, 0);
            });

            requestAnimationFrame(animate);
        }

        animate();

        // Contr√¥les
        function goToSun() {
            camera.x = 0;
            camera.y = 5;
            camera.z = 15;
        }

        function goToEarth() {
            const body = celestialBodies[3];
            camera.x = body.x;
            camera.y = body.y + 5;
            camera.z = body.z + 15;
        }

        function goToMars() {
            const body = celestialBodies[4];
            camera.x = body.x;
            camera.y = body.y + 5;
            camera.z = body.z + 15;
        }

        function resetView() {
            camera.x = 0;
            camera.y = 15;
            camera.z = 50;
        }

        function toggleOrbit() {
            showOrbits = !showOrbits;
        }

        function toggleLabels() {
            showLabels = !showLabels;
        }

        function goBack() {
            window.location.href = '/';
        }

        // Souris
        let isDragging = false;
        let lastX, lastY;

        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            lastX = e.clientX;
            lastY = e.clientY;
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const dx = e.clientX - lastX;
                const dy = e.clientY - lastY;
                
                camera.rotY += dx * 0.005;
                camera.rotX += dy * 0.005;
                
                lastX = e.clientX;
                lastY = e.clientY;
            }
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
        });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const zoom = e.deltaY > 0 ? 1.1 : 0.9;
            camera.z *= zoom;
        });

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        });
    </script>
</body>
</html>
